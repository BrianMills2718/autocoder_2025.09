# System Vocabulary

This document is the single source of truth for key architectural terms used in Autocoder. Its purpose is to eliminate ambiguity in documentation, code, and LLM-generated outputs.

| Term | Definition | Example | Notes |
|---|---|---|---|
| **Port Semantic Class** | A high-level, logical category that defines a port's role and enforces connectivity rules (e.g., data_in ports can only connect to data_out ports). | `data_in`, `data_out`, `control_in`, `metrics_out` | Not a Python construct; semantic classes are enforced by the ComponentRegistry during validation. |
| **Implementation** | The specific Python class that provides the concrete logic for a component. | `APIEndpoint`, `StreamProcessor` | Implementations define their behavior through explicit port descriptors with semantic classes and schemas. |
| **Inheritance** | The mechanism by which all components derive their core functionality. | `class MyStore(ComposedComponent):` | All implementations inherit (directly or via mix-ins) from ComposedComponent. Some may extend specialized mix-ins generated by the DSL (e.g., `class FraudDetector(ModelBase)`). |
| **Capability** | A self-contained, single-purpose class providing a cross-cutting concern that is injected into a `ComposedComponent`. | `RetryHandler`, `SchemaValidator` | Enables composition over inheritance. See also: Capability Tier System. |
| **Binding** | A declarative statement in the blueprint that defines the data flow from one component's output stream to another's input stream. | `from: A, on: output, to: B, as: input` | A single binding may fan-out to multiple `to:` entries (parser supports arrays). | 