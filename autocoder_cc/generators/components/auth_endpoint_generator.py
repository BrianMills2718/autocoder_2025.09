from autocoder_cc.observability.structured_logging import get_logger
"""
Authentication endpoint generator for login/logout/refresh functionality.
Generates FastAPI endpoints with JWT authentication.
"""
from typing import Dict, Any


class AuthEndpointGenerator:
    """Generates authentication endpoints with JWT support."""
    
    def __init__(self):
        self.api_version = "1"  # Default API version
    
    def generate(self, component_spec: Dict[str, Any]) -> str:
        """Generate authentication endpoint component code."""
        name = component_spec.get('name', 'auth')
        config = component_spec.get('config', {})
        
        # Extract configuration
        enable_refresh = config.get('enable_refresh', True)
        token_expiry_hours = config.get('token_expiry_hours', 24)
        api_version = config.get('api_version', self.api_version)
        
        return f'''"""
Authentication endpoint component with JWT support.
Generated by AuthEndpointGenerator.
"""
import logging
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
import jwt
import bcrypt
import anyio

from autocoder_cc.components.composed_base import ComposedComponent
from autocoder_cc.capabilities import (
    SchemaValidator,
    HealthChecker,
    MetricsCollector,
    RateLimiter,
)
from autocoder_cc.core.config import settings


# Request/Response models
class LoginRequest(BaseModel):
    """Login request model."""
    username: str = Field(..., description="Username")
    password: str = Field(..., description="Password")


class LoginResponse(BaseModel):
    """Login response model."""
    access_token: str = Field(..., description="JWT access token")
    token_type: str = Field(default="bearer", description="Token type")
    expires_in: int = Field(..., description="Token expiry in seconds")
    {"refresh_token: Optional[str] = Field(default=None, description='Refresh token')" if enable_refresh else ""}


class RefreshRequest(BaseModel):
    """Token refresh request model."""
    refresh_token: str = Field(..., description="Refresh token")


class UserInfo(BaseModel):
    """User information model."""
    username: str = Field(..., description="Username")
    roles: list[str] = Field(default_factory=list, description="User roles")


class {name.title()}Component(ComposedComponent):
    """
    Authentication endpoint component using composition pattern.
    Provides login, logout, and token refresh functionality.
    """
    
    def __init__(self, name: str, config: Dict[str, Any]):
        super().__init__(name, config)
        
        # Initialize capabilities via composition
        self.schema_validator = SchemaValidator(strict_mode=True)
        self.health_checker = HealthChecker()
        self.metrics = MetricsCollector(namespace=name)
        self.rate_limiter = RateLimiter(
            rate=10,  # 10 login attempts
            per=60    # per minute
        )
        
        # JWT configuration with crypto policy enforcement
        self.jwt_secret_key = settings.DEFAULT_JWT_SECRET_KEY
        self.token_expiry_hours = {token_expiry_hours}
        
        # Load crypto policy enforcer for environment-specific JWT algorithms
        from autocoder_cc.security.crypto_policy_enforcer import get_crypto_enforcer
        self.crypto_enforcer = get_crypto_enforcer()
        self.jwt_algorithm = self.crypto_enforcer.get_default_jwt_algorithm()
        self.allowed_algorithms = self.crypto_enforcer.get_jwt_decode_algorithms()
        
        # Security
        self.security = HTTPBearer()
        
        # SECURITY: No default users - all users must be created securely
        # In production, use a database with proper user management
        self.users = {{}}
        
        # IMPORTANT: To create initial users, use environment variables or
        # a secure user creation endpoint with strong password requirements
        self._setup_initial_users_from_env()
        
        # Configure schemas
        self.schema_validator.register_schema('login_request', LoginRequest)
        self.schema_validator.register_schema('login_response', LoginResponse)
        {"self.schema_validator.register_schema('refresh_request', RefreshRequest)" if enable_refresh else ""}
        
        # Add health checks
        self.health_checker.add_check('auth_ready', self._check_auth_ready)
        
        # Logging
        self.logger = get_logger(f"{{__name__}}.{{name}}")
        
        # FastAPI app reference
        self.app: Optional[FastAPI] = None
    
    async def setup(self):
        """Initialize component."""
        await super().setup()
        await self.health_checker.start_monitoring()
        self.logger.info(f"{{self.name}} authentication endpoint initialized")
    
    def _setup_initial_users_from_env(self):
        """Securely setup initial users from environment variables."""
        import os
        
        # Check for initial admin user from environment
        admin_username = os.getenv('INITIAL_ADMIN_USERNAME')
        admin_password = os.getenv('INITIAL_ADMIN_PASSWORD')
        
        if admin_username and admin_password:
            # Validate password strength
            if len(admin_password) < 12:
                raise ValueError("INITIAL_ADMIN_PASSWORD must be at least 12 characters")
            
            self.users[admin_username] = {{
                "password_hash": bcrypt.hashpw(admin_password.encode('utf-8'), bcrypt.gensalt()),
                "roles": ["admin", "user"]
            }}
            # Clear password from memory
            admin_password = None
        
        # Log setup status (without credentials)
        self.logger.info(f"Auth component initialized with {{len(self.users)}} users")
    
    async def cleanup(self):
        """Cleanup component resources."""
        await self.health_checker.stop_monitoring()
        await super().cleanup()
    
    def register_routes(self, app: FastAPI):
        """Register FastAPI routes."""
        self.app = app
        
        @app.post("/api/v{api_version}/auth/login", response_model=LoginResponse)
        async def login(request: LoginRequest):
            """Authenticate user and return JWT token."""
            async with self.metrics.timer("login_duration"):
                try:
                    # Rate limit check
                    if not await self.rate_limiter.acquire():
                        raise HTTPException(
                            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                            detail="Too many login attempts"
                        )
                    
                    # Verify credentials
                    user = self.users.get(request.username)
                    if not user or not bcrypt.checkpw(
                        request.password.encode('utf-8'),
                        user['password_hash']
                    ):
                        await self.metrics.increment("login_failed_total")
                        raise HTTPException(
                            status_code=status.HTTP_401_UNAUTHORIZED,
                            detail="Invalid username or password"
                        )
                    
                    # Generate tokens
                    access_token = self.generate_token(
                        request.username,
                        user['roles'],
                        timedelta(hours=self.token_expiry_hours)
                    )
                    
                    {"refresh_token = self.generate_token(request.username, user['roles'], timedelta(days=30), is_refresh=True)" if enable_refresh else ""}
                    
                    await self.metrics.increment("login_success_total")
                    self.logger.info(f"User {{request.username}} logged in successfully")
                    
                    return LoginResponse(
                        access_token=access_token,
                        token_type="bearer",
                        expires_in=self.token_expiry_hours * 3600,
                        {"refresh_token=refresh_token" if enable_refresh else ""}
                    )
                    
                except HTTPException:
                    raise
                except Exception as e:
                    self.logger.error(f"Login error: {{e}}")
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Authentication service error"
                    )
        
        @app.get("/api/v{api_version}/auth/me", response_model=UserInfo)
        async def get_current_user(token: str = Depends(self.verify_token)):
            """Get current user information from token."""
            return UserInfo(
                username=token.get("sub", "unknown"),
                roles=token.get("roles", [])
            )
        
        {"@app.post('/api/v{api_version}/auth/refresh', response_model=LoginResponse)" if enable_refresh else ""}
        {"async def refresh_token(request: RefreshRequest):" if enable_refresh else ""}
        {'    """Refresh access token using refresh token."""' if enable_refresh else ""}
        {"    try:" if enable_refresh else ""}
        {"        # Verify refresh token" if enable_refresh else ""}
        {"        payload = jwt.decode(" if enable_refresh else ""}
        {"            request.refresh_token," if enable_refresh else ""}
        {"            self.jwt_secret_key," if enable_refresh else ""}
        {"            algorithms=self.allowed_algorithms" if enable_refresh else ""}
        {"        )" if enable_refresh else ""}
        {"        " if enable_refresh else ""}
        {"        if not payload.get('is_refresh'):" if enable_refresh else ""}
        {"            raise HTTPException(" if enable_refresh else ""}
        {"                status_code=status.HTTP_401_UNAUTHORIZED," if enable_refresh else ""}
        {'                detail="Invalid refresh token"' if enable_refresh else ""}
        {"            )" if enable_refresh else ""}
        {"        " if enable_refresh else ""}
        {"        # Generate new access token" if enable_refresh else ""}
        {"        username = payload.get('sub')" if enable_refresh else ""}
        {"        roles = payload.get('roles', [])" if enable_refresh else ""}
        {"        " if enable_refresh else ""}
        {"        new_access_token = self.generate_token(" if enable_refresh else ""}
        {"            username," if enable_refresh else ""}
        {"            roles," if enable_refresh else ""}
        {"            timedelta(hours=self.token_expiry_hours)" if enable_refresh else ""}
        {"        )" if enable_refresh else ""}
        {"        " if enable_refresh else ""}
        {"        return LoginResponse(" if enable_refresh else ""}
        {"            access_token=new_access_token," if enable_refresh else ""}
        {"            token_type='bearer'," if enable_refresh else ""}
        {"            expires_in=self.token_expiry_hours * 3600" if enable_refresh else ""}
        {"        )" if enable_refresh else ""}
        {"        " if enable_refresh else ""}
        {"    except jwt.InvalidTokenError:" if enable_refresh else ""}
        {"        raise HTTPException(" if enable_refresh else ""}
        {"            status_code=status.HTTP_401_UNAUTHORIZED," if enable_refresh else ""}
        {'            detail="Invalid refresh token"' if enable_refresh else ""}
        {"        )" if enable_refresh else ""}
    
    async def verify_token(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())):
        """Verify JWT token and return decoded payload."""
        if not credentials:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing authentication credentials",
                headers={{"WWW-Authenticate": "Bearer"}},
            )
        
        try:
            payload = jwt.decode(
                credentials.credentials,
                self.jwt_secret_key,
                algorithms=self.allowed_algorithms
            )
            
            # Don't accept refresh tokens for regular auth
            if payload.get('is_refresh'):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid token type",
                    headers={{"WWW-Authenticate": "Bearer"}},
                )
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired",
                headers={{"WWW-Authenticate": "Bearer"}},
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token",
                headers={{"WWW-Authenticate": "Bearer"}},
            )
    
    def generate_token(self, username: str, roles: list[str], 
                      expires_delta: timedelta, is_refresh: bool = False) -> str:
        """Generate a JWT token."""
        expire = datetime.utcnow() + expires_delta
        
        payload = {{
            "sub": username,
            "roles": roles,
            "exp": expire,
            "iat": datetime.utcnow(),
            "is_refresh": is_refresh
        }}
        
        return jwt.encode(payload, self.jwt_secret_key, algorithm=self.jwt_algorithm)
    
    async def _check_auth_ready(self) -> bool:
        """Health check for auth readiness."""
        return self.app is not None and bool(self.jwt_secret_key)
    
    async def process(self):
        """Main processing loop (minimal for auth endpoints)."""
        # Auth endpoints primarily respond to HTTP requests
        # No continuous processing needed
        pass'''