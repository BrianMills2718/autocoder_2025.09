"""
Directory structure generator plugin for the scaffold generation system.
Creates the project directory structure following best practices.
"""
from typing import Dict, Any
from pathlib import Path
import os
import shutil


class StructureGenerator:
    """Generates directory structure for autocoder systems."""
    
    # Define the essential framework modules required by every generated system.
    FRAMEWORK_MODULES_TO_COPY = [
        "autocoder/components",
        "autocoder/orchestration"
    ]
    
    def __init__(self, base_output_dir: Path):
        self.base_output_dir = Path(base_output_dir)
    
    def create_structure(self, blueprint: Dict[str, Any]) -> bool:
        """
        Create directory structure for the system, including copying
        the core framework files to make it standalone.
        
        Returns:
            bool: True if structure was created successfully
        """
        system = blueprint.get('system', {})
        system_name = system.get('name', 'autocoder-app')
        
        # Create main project directory
        project_dir = self.base_output_dir / system_name
        project_dir.mkdir(parents=True, exist_ok=True)
        
        # Create standard directories
        directories = [
            'components',      # Component implementations
            'tests',          # Test files
            'config',         # Configuration files
            'scripts',        # Utility scripts
            'docs',           # Documentation
            'k8s',            # Kubernetes manifests
            '.github/workflows'  # GitHub Actions
        ]
        
        for directory in directories:
            (project_dir / directory).mkdir(parents=True, exist_ok=True)
        
        # Copy core framework files
        self._copy_framework_modules(project_dir)
        
        # Create __init__.py files for Python packages
        for package in ['components', 'tests', 'config']:
            init_file = project_dir / package / '__init__.py'
            init_file.write_text(f'"""Generated {package} package."""\n')
        
        # Create standard files
        self._create_gitignore(project_dir)
        self._create_readme(project_dir, system)
        self._create_env_example(project_dir)
        self._create_settings_file(project_dir)
        
        return True
    
    def _copy_framework_modules(self, project_dir: Path):
        """Copy core framework modules to make the system standalone."""
        # Determine the absolute path to the generator's root directory
        generator_root_path = Path(__file__).resolve().parents[3]
        
        for module_path_str in self.FRAMEWORK_MODULES_TO_COPY:
            module_path = Path(module_path_str)
            source = generator_root_path / module_path
            destination = project_dir / module_path
            
            # Ensure the parent directory exists
            destination.parent.mkdir(parents=True, exist_ok=True)
            
            if source.exists() and source.is_dir():
                # Remove destination if it exists (to overwrite)
                if destination.exists():
                    shutil.rmtree(destination)
                shutil.copytree(source, destination)
    
    def _create_gitignore(self, project_dir: Path):
        """Create .gitignore file."""
        gitignore_content = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
.venv
*.egg-info/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Testing
.coverage
.pytest_cache/
htmlcov/

# Environment
.env
.env.local

# Logs
*.log
logs/

# Generated
generated_systems/
temp/
build/
dist/
"""
        (project_dir / '.gitignore').write_text(gitignore_content)
    
    def _create_readme(self, project_dir: Path, system: Dict[str, Any]):
        """Create README.md file."""
        from autocoder_cc.generators.config import generator_settings
        
        system_name = system.get('name', 'autocoder-app')
        api_port = system.get('port', generator_settings.default_api_port)
        readme_content = f"""# {system_name}

Generated by Autocoder V5.2 Enterprise Edition

## Overview
{system.get('description', 'A distributed system generated by Autocoder')}

## Architecture
- Built with FastAPI for native async support
- Uses anyio streams for component communication
- No synchronous bridges or queues
- Follows Enterprise Roadmap v2 requirements

## Running Locally

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Set up environment:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

3. Run the application:
   ```bash
   python main.py
   ```

## Running with Docker

```bash
docker-compose up
```

## API Documentation

Once running, visit:
- API Docs: http://localhost:{api_port}/docs
- Health Check: http://localhost:{api_port}/health
- Metrics: http://localhost:{api_port}/metrics

## Testing

```bash
pytest tests/
```

## Deployment

See the `k8s/` directory for Kubernetes manifests.
"""
        (project_dir / 'README.md').write_text(readme_content)
    
    def _create_env_example(self, project_dir: Path):
        """Create .env.example file."""
        from autocoder_cc.generators.config import generator_settings
        
        env_example = f"""# Application Configuration
ENVIRONMENT=development
DEBUG_MODE=true
LOG_LEVEL=INFO

# API Configuration  
API_PREFIX=/api/v1
API_VERSION=1.0.0

# Database Configuration (if needed)
DATABASE_URL=postgresql://user:password@localhost/dbname

# Redis Configuration (if needed)
REDIS_URL=redis://{generator_settings.redis_host}:{generator_settings.redis_port}/0

# RabbitMQ Configuration (if needed)
RABBITMQ_URL=amqp://guest:guest@localhost/

# Security
# JWT_SECRET_KEY=your_secure_jwt_secret_key_here

# Monitoring
ENABLE_METRICS=true
METRICS_PORT=9090
"""
        (project_dir / '.env.example').write_text(env_example)
    
    def _create_settings_file(self, project_dir: Path):
        """Create config/settings.py for generated system."""
        settings_content = '''"""
Configuration for the generated system.
Uses Pydantic Settings for validation and environment loading.
"""
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field
from typing import Optional


class Settings(BaseSettings):
    """Application settings."""
    
    model_config = SettingsConfigDict(
        env_file='.env',
        env_file_encoding='utf-8',
        extra='ignore'
    )
    
    # Environment
    environment: str = "development"
    debug_mode: bool = True
    log_level: str = "INFO"
    
    # API Configuration
    api_prefix: str = "/api/v1"
    api_version: str = "1.0.0"
    
    # Server Configuration
    host: str = "0.0.0.0"
    port: int = 8000
    
    # Database Configuration
    database_url: Optional[str] = None
    
    # Redis Configuration
    redis_url: Optional[str] = None
    
    # RabbitMQ Configuration
    rabbitmq_url: Optional[str] = None
    
    # Security
    jwt_secret_key: str = Field(..., description="JWT secret key for token signing")
    jwt_algorithm: str = "HS256"
    jwt_expiration_minutes: int = 30
    
    # Monitoring
    enable_metrics: bool = True
    metrics_port: int = 9090
    enable_tracing: bool = False
    tracing_endpoint: Optional[str] = None


# Create singleton instance
settings = Settings()
'''
        (project_dir / 'config' / 'settings.py').write_text(settings_content)


# Keep the legacy function for backward compatibility
def create_project_structure(blueprint: dict, target_directory: str) -> str:
    """Legacy function for backward compatibility."""
    generator = StructureGenerator(Path(target_directory))
    generator.create_structure({'system': blueprint})
    return str(generator.base_output_dir / blueprint.get("name", "generated_system")) 