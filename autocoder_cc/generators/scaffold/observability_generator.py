#!/usr/bin/env python3
"""
Observability Generator - Shared Observability Module Generation
===============================================================

Phase 2A Implementation: Extracts duplicated observability code into shared module
Replaces 143 lines of boilerplate per component with shared imports

Created: 2025-07-25
Purpose: Eliminate massive code duplication in generated components
"""

from typing import Dict, Any, Optional, List, Union, Tuple
from pathlib import Path
import time

class ObservabilityGenerator:
    """
    Generates shared observability module for component systems
    
    Extracts all observability boilerplate from individual components
    into a single shared module that all components can import from.
    """
    
    def __init__(self):
        self.generated_at = time.time()
    
    def generate_observability_module(self, 
                                    system_name: str = "generated_system",
                                    include_prometheus: bool = True) -> str:
        """
        Generate complete observability module with all shared classes
        
        Args:
            system_name: Name of the system for logging context
            include_prometheus: Whether to include Prometheus metrics support
            
        Returns:
            Complete Python module code as string
        """
        
        module_content = self._generate_module_header(system_name)
        module_content += self._generate_imports()
        module_content += self._generate_logger_function()
        module_content += self._generate_metrics_collector_class(include_prometheus)
        module_content += self._generate_tracer_classes()
        module_content += self._generate_component_status_class()
        module_content += self._generate_base_component_class()
        module_content += self._generate_module_footer()
        
        return module_content
    
    def _generate_module_header(self, system_name: str) -> str:
        """Generate module header with documentation"""
        return f'''#!/usr/bin/env python3
"""
Shared Observability Module for {system_name}
============================================

Generated by ObservabilityGenerator on {time.strftime('%Y-%m-%d %H:%M:%S')}

This module contains all observability infrastructure shared across components:
- StandaloneMetricsCollector: Metrics collection and reporting
- StandaloneTracer: Distributed tracing support  
- StandaloneSpan: Span implementation for tracing
- ComponentStatus: Component state tracking
- ComposedComponent: Base class for all components
- SpanStatus: OpenTelemetry-compatible span status codes

Usage:
    from observability import ComposedComponent, SpanStatus
    
    class MyComponent(ComposedComponent):
        def __init__(self, name: str, config: Dict[str, Any] = None):
            super().__init__(name, config)
            # Component now has metrics, tracing, and health checks
"""

'''

    def _generate_imports(self) -> str:
        """Generate required imports for observability module"""
        return '''import logging
import time
from typing import Dict, Any, Optional, List, Union, Tuple
from dataclasses import dataclass, field


class SpanStatus:
    """OpenTelemetry-compatible span status codes"""
    OK = "OK"
    ERROR = "ERROR"
    UNSET = "UNSET"

'''

    def _generate_logger_function(self) -> str:
        """Generate logger setup function"""
        return '''def get_logger(name: str) -> logging.Logger:
    """Get configured logger for component"""
    logger = logging.getLogger(name)
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    return logger


'''

    def _generate_metrics_collector_class(self, include_prometheus: bool = True) -> str:
        """Generate StandaloneMetricsCollector class"""
        prometheus_section = ''
        if include_prometheus:
            prometheus_section = '''
    def export_prometheus_metrics(self) -> str:
        """Export metrics in Prometheus format"""
        lines = []
        for key, value in self.metrics.items():
            # Convert to Prometheus format
            metric_name = key.replace('.', '_').replace('-', '_')
            if isinstance(value, (int, float)):
                lines.append(f"{metric_name} {value}")
            elif isinstance(value, list):
                # Histogram - export count and sum
                lines.append(f"{metric_name}_count {len(value)}")
                if value:
                    lines.append(f"{metric_name}_sum {sum(value)}")
        return "\\n".join(lines)'''
        
        return f'''class StandaloneMetricsCollector:
    """Standalone metrics collector for observability"""
    
    def __init__(self, component_name: str):
        self.component_name = component_name
        self.metrics = {{}}
        self.logger = get_logger(f"metrics.{{component_name}}")
    
    def counter(self, name: str, value: int = 1, tags: Dict[str, str] = None):
        """Record a counter metric"""
        key = f"{{self.component_name}}.{{name}}"
        self.metrics[key] = self.metrics.get(key, 0) + value
        self.logger.debug(f"Counter {{key}}: {{self.metrics[key]}}")
    
    def increment_counter(self, name: str, value: int = 1, tags: Dict[str, str] = None):
        """Alias for counter() to support generated components that use increment_counter"""
        return self.counter(name, value, tags)
    
    def gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """Record a gauge metric"""
        key = f"{{self.component_name}}.{{name}}"
        self.metrics[key] = value
        self.logger.debug(f"Gauge {{key}}: {{value}}")
    
    def set_gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """Alias for gauge() to support generated components that use set_gauge"""
        return self.gauge(name, value, tags)
    
    def record_gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """
        Record gauge metric - compatibility method for generated components.
        This delegates to gauge() for backward compatibility.
        """
        return self.gauge(name, value, tags)
    
    def histogram(self, name: str, value: float, tags: Dict[str, str] = None):
        """Record a histogram metric"""
        key = f"{{self.component_name}}.{{name}}"
        if key not in self.metrics:
            self.metrics[key] = []
        self.metrics[key].append(value)
        self.logger.debug(f"Histogram {{key}}: {{value}}")
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get all recorded metrics"""
        return self.metrics.copy(){prometheus_section}


'''

    def _generate_tracer_classes(self) -> str:
        """Generate StandaloneTracer and StandaloneSpan classes"""
        return '''class StandaloneTracer:
    """Standalone tracer for observability"""
    
    # OpenTelemetry-compatible status codes
    class StatusCode:
        ERROR = "ERROR"
        OK = "OK"
        UNSET = "UNSET"
    
    def __init__(self, component_name: str):
        self.component_name = component_name
        self.logger = get_logger(f"tracer.{component_name}")
        self.active_spans = []
    
    def start_span(self, name: str, parent_span=None, attributes: Dict[str, Any] = None, **kwargs):
        """Start a new span with flexible signature for compatibility
        
        Args:
            name: Span name
            parent_span: Optional parent span (for child_of compatibility)
            attributes: Optional attributes dictionary
            **kwargs: Additional arguments for compatibility (e.g., child_of)
        """
        # Handle both parent_span and child_of for compatibility
        if not parent_span and 'child_of' in kwargs:
            parent_span = kwargs['child_of']
        
        # Also support tags parameter
        tags = kwargs.get('tags', {})
        if attributes:
            tags.update(attributes)
        
        span = StandaloneSpan(name, self.logger, tags, parent_span)
        if attributes:
            for key, value in attributes.items():
                span.set_attribute(key, value)
        self.active_spans.append(span)
        return span
    
    def start_as_current_span(self, name: str, attributes: Dict[str, Any] = None, **kwargs):
        """Context manager for span creation - updated for compatibility"""
        # Support both parent and child_of parameters
        parent = kwargs.get('parent') or kwargs.get('child_of')
        span = self.start_span(name, parent_span=parent, attributes=attributes)
        return span


class StandaloneSpan:
    """Standalone span implementation"""
    
    def __init__(self, name: str, logger: logging.Logger, tags: Dict[str, str] = None, parent_span=None):
        self.name = name
        self.logger = logger  
        self.tags = tags or {}
        self.parent_span = parent_span
        self.start_time = time.time()
        self.attributes = {}
    
    def __enter__(self):
        self.logger.debug(f"Starting span: {self.name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time
        self.logger.debug(f"Completed span: {self.name} ({duration:.3f}s)")
    
    def set_attribute(self, key: str, value: Any):
        """Set span attribute"""
        self.attributes[key] = value
        self.tags[key] = str(value)
    
    def set_tag(self, key: str, value: str):
        """Set span tag"""
        self.tags[key] = value
    
    def set_status(self, status_code: str, description: str = None):
        """Set span status (OpenTelemetry compatible)"""
        self.status = status_code
        if description:
            self.description = description
            self.set_attribute("status.description", description)
        self.set_attribute("status.code", status_code)
        if status_code == "ERROR":
            self.logger.warning(f"Span {self.name} set to ERROR status: {description}")
        else:
            self.logger.debug(f"Span {self.name} status: {status_code}")
    
    def record_exception(self, exception: Exception):
        """Record an exception on the span"""
        self.set_attribute("error", True)
        self.set_attribute("error.type", type(exception).__name__)
        self.set_attribute("error.message", str(exception))
    
    def end(self):
        """End the span explicitly"""
        duration = time.time() - self.start_time
        self.logger.debug(f"Ended span: {self.name} ({duration:.3f}s)")


'''

    def _generate_component_status_class(self) -> str:
        """Generate ComponentStatus dataclass"""
        return '''@dataclass
class ComponentStatus:
    """Status information for a component"""
    is_running: bool = False
    is_healthy: bool = True
    items_processed: int = 0
    errors_encountered: int = 0
    last_error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


'''

    def _generate_base_component_class(self) -> str:
        """Generate ComposedComponent class with communication support"""
        return '''class ComposedComponent:
    """
    Standalone base class for all components.
    Provides all functionality without requiring autocoder_cc imports.
    
    Features:
    - Metrics collection via self.metrics_collector
    - Distributed tracing via self.tracer  
    - Health status tracking via self._status
    - Error handling and logging via self.logger
    - Inter-component communication via self.communicator
    - Lifecycle management (setup/teardown)
    """
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        self.name = name
        self.config = config or {}
        self.logger = get_logger(f"Component.{name}")
        self.metrics_collector = StandaloneMetricsCollector(name)
        self.tracer = StandaloneTracer(name)
        self.created_at = time.time()
        
        # Component state
        self._status = ComponentStatus()
        
        # Communication support - will be set by system harness
        self.communicator = None
        self.registry = None
        
        self.logger.info(f"Component {self.name} initialized")
    
    def get_health_status(self) -> Dict[str, Any]:
        """Get component health status"""
        return {
            'status': 'healthy' if self._status.errors_encountered == 0 else 'degraded',
            'component': self.name,
            'type': self.__class__.__name__,
            'error_count': self._status.errors_encountered,
            'last_error': self._status.last_error,
            'uptime': time.time() - self.created_at,
            'items_processed': self._status.items_processed,
            'is_running': self._status.is_running,
            'is_healthy': self._status.is_healthy
        }
    
    async def health_check(self) -> Dict[str, Any]:
        """Async health check"""
        return self.get_health_status()
    
    def handle_error(self, error: Exception, context: str = "") -> Dict[str, Any]:
        """Handle and log errors, return error response"""
        self._status.errors_encountered += 1
        error_msg = f"{context}: {str(error)}" if context else str(error)
        self._status.last_error = error_msg
        self._status.is_healthy = False
        self.logger.error(f"Error in {self.name}: {error_msg}")
        self.metrics_collector.counter("errors", 1)
        
        # Return standardized error response
        return {
            "status": "error",
            "message": error_msg,
            "error_type": type(error).__name__,
            "component": self.name
        }
    
    def increment_processed(self):
        """Increment processed items counter"""
        self._status.items_processed += 1
        self.metrics_collector.counter("items_processed", 1)
    
    async def setup(self, harness_context: Optional[Dict[str, Any]] = None):
        """Initialize the component"""
        self._status.is_running = True
        self.logger.info(f"Component {self.name} setup completed")
    
    async def teardown(self):
        """Cleanup the component"""
        self._status.is_running = False
        self.logger.info(f"Component {self.name} teardown completed")
    
    def set_communicator(self, communicator, registry):
        """Set communication framework (called by system harness)"""
        self.communicator = communicator
        self.registry = registry
        self.logger.info(f"Communication framework set for {self.name}")
    
    async def send_to_component(self, target_component: str, data: Dict[str, Any], target_port: str = "input") -> Dict[str, Any]:
        """Send data to another component"""
        if not self.communicator:
            self.logger.warning(f"No communicator set for {self.name}, cannot send to {target_component}")
            return {"status": "error", "message": "No communicator available"}
        
        return await self.communicator.send_to_component(
            source_component=self.name,
            target_component=target_component,
            data=data,
            target_port=target_port
        )
    
    async def query_component(self, target_component: str, query: Dict[str, Any], target_port: str = "query") -> Dict[str, Any]:
        """Query another component and wait for response"""
        if not self.communicator:
            self.logger.warning(f"No communicator set for {self.name}, cannot query {target_component}")
            return {"status": "error", "message": "No communicator available"}
        
        return await self.communicator.query_component(
            source_component=self.name,
            target_component=target_component,
            query=query,
            target_port=target_port
        )
    
    async def route_to_bindings(self, data: Dict[str, Any], source_port: str = "output") -> List[Dict[str, Any]]:
        """Route data to all bound components based on blueprint"""
        if not self.communicator:
            self.logger.warning(f"No communicator set for {self.name}, cannot route data")
            return [{"status": "error", "message": "No communicator available"}]
        
        return await self.communicator.route_message(
            source_component=self.name,
            data=data,
            source_port=source_port
        )
    
    def __str__(self) -> str:
        """String representation of component"""
        return f"{self.__class__.__name__}(name={self.name}, healthy={self._status.is_healthy})"
    
    def __repr__(self) -> str:
        """Detailed representation of component"""
        return (f"{self.__class__.__name__}(name='{self.name}', "
                f"processed={self._status.items_processed}, "
                f"errors={self._status.errors_encountered})")


'''

    def _generate_module_footer(self) -> str:
        """Generate module footer with metadata"""
        return '''# Module metadata
__version__ = "1.0.0"
__author__ = "ObservabilityGenerator" 
__generated_at__ = "{}"

# Export public classes
__all__ = [
    "get_logger",
    "StandaloneMetricsCollector", 
    "StandaloneTracer",
    "StandaloneSpan",
    "ComponentStatus",
    "ComposedComponent"
]
'''.format(time.strftime('%Y-%m-%d %H:%M:%S'))

    def generate_import_statement(self) -> str:
        """Generate import statement for components to use"""
        return "from observability import ComposedComponent\n"
    
    def get_component_template_changes(self) -> Dict[str, str]:
        """
        Get template changes needed for component generation
        
        Returns:
            Dictionary mapping old patterns to new patterns
        """
        return {
            # Remove inline class definitions
            "# Include all observability classes inline": "# Import from shared module",
            
            # Replace class inheritance pattern
            "class Generated{component_type}_{name}(ComposedComponent):": 
                "class Generated{component_type}_{name}(ComposedComponent):",
            
            # Add import at top of file
            "import logging\nimport time": 
                "import logging\nimport time\nfrom observability import ComposedComponent",
            
            # Remove boilerplate class definitions
            "class StandaloneMetricsCollector:": "# StandaloneMetricsCollector imported from observability",
            "class StandaloneTracer:": "# StandaloneTracer imported from observability", 
            "class StandaloneSpan:": "# StandaloneSpan imported from observability",
            "class ComponentStatus:": "# ComponentStatus imported from observability",
            "class ComposedComponent:": "# ComposedComponent imported from observability"
        }
    
    def estimate_line_savings(self, num_components: int) -> Dict[str, int]:
        """
        Estimate line savings from using shared module
        
        Args:
            num_components: Number of components in the system
            
        Returns:
            Dictionary with line count analysis
        """
        lines_per_boilerplate = 143  # From analysis
        shared_module_lines = 180    # Estimated shared module size
        import_lines_per_component = 1  # Single import line
        
        before_lines = num_components * lines_per_boilerplate
        after_lines = shared_module_lines + (num_components * import_lines_per_component)
        lines_saved = before_lines - after_lines
        
        return {
            'before_total_lines': before_lines,
            'after_total_lines': after_lines, 
            'lines_saved': lines_saved,
            'percentage_reduction': (lines_saved / before_lines) * 100,
            'shared_module_lines': shared_module_lines,
            'components_count': num_components
        }


# Convenience function for system generation integration
def generate_shared_observability(system_name: str, 
                                output_dir: Path,
                                include_prometheus: bool = True) -> Path:
    """
    Generate shared observability module and write to file
    
    Args:
        system_name: Name of the system
        output_dir: Directory to write observability.py
        include_prometheus: Include Prometheus metrics export
        
    Returns:
        Path to generated observability.py file
    """
    generator = ObservabilityGenerator()
    content = generator.generate_observability_module(system_name, include_prometheus)
    
    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Write observability module
    observability_file = output_dir / "observability.py"
    observability_file.write_text(content)
    
    return observability_file