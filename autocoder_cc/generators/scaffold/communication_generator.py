"""
Component Communication Framework Generator

This module generates the communication infrastructure that enables real inter-component
communication in generated systems, replacing simulation patterns with actual message passing.

Key Features:
- ComponentCommunicator: Handles message routing between components
- ComponentRegistry: Component discovery and registration  
- Blueprint-driven routing configuration
- Async message passing with error handling
"""

import json
from typing import Dict, Any, List, Optional
from datetime import datetime


class ComponentCommunicationGenerator:
    """
    Generates communication framework code for component-to-component messaging
    
    This replaces the current pattern where components return data indicating
    routing intent with actual inter-component communication.
    """
    
    def __init__(self):
        self.template_registry = {}
    
    def generate_communication_module(self, 
                                    system_name: str,
                                    bindings: List[Dict[str, Any]] = None,
                                    components: List[Dict[str, Any]] = None) -> str:
        """
        Generate complete communication module with registry and message passing
        
        Args:
            system_name: Name of the system being generated
            bindings: Blueprint binding definitions for routing
            components: Component definitions for registry setup
            
        Returns:
            Complete Python module code for component communication
        """
        
        # Build routing configuration from blueprint bindings
        routing_config = self._build_routing_config(bindings or [])
        component_config = self._build_component_config(components or [])
        
        module_content = f'''#!/usr/bin/env python3
"""
Component Communication Framework for {system_name}
==================================================

Generated by ComponentCommunicationGenerator on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

This module provides the communication infrastructure for real inter-component
message passing based on blueprint bindings.

Classes:
- ComponentRegistry: Component discovery and registration
- ComponentCommunicator: Message routing and delivery  
- CommunicationConfig: Routing configuration from blueprint
- MessageEnvelope: Structured message wrapper

Usage:
    from communication import ComponentRegistry, ComponentCommunicator
    
    # In component initialization
    registry = ComponentRegistry()
    communicator = ComponentCommunicator(registry)
    
    # In component process_item method
    result = await communicator.send_to_component("target_component", data)
"""

import asyncio
import logging
import time
import json
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, field
from datetime import datetime


def get_communication_logger(name: str) -> logging.Logger:
    """Get configured logger for communication framework"""
    logger = logging.getLogger(f"communication.{{name}}")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    return logger


@dataclass
class MessageEnvelope:
    """Structured wrapper for inter-component messages"""
    source_component: str
    target_component: str
    target_port: str
    data: Dict[str, Any]
    correlation_id: str = field(default_factory=lambda: f"msg_{{int(time.time() * 1000)}}")
    timestamp: float = field(default_factory=time.time)
    message_type: str = "data"  # data, query, command, response
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary for transmission"""
        return {{
            "source_component": self.source_component,
            "target_component": self.target_component,
            "target_port": self.target_port,
            "data": self.data,
            "correlation_id": self.correlation_id,
            "timestamp": self.timestamp,
            "message_type": self.message_type
        }}


class ComponentRegistry:
    """
    Component discovery and registration system
    
    Manages the mapping of component names to component instances,
    enabling message routing between components.
    """
    
    def __init__(self):
        self._components: Dict[str, Any] = {{}}
        self._component_ports: Dict[str, Dict[str, str]] = {{}}
        self.logger = get_communication_logger("ComponentRegistry")
        
    def register_component(self, name: str, component: Any, ports: Dict[str, str] = None) -> None:
        """
        Register a component for message routing
        
        Args:
            name: Component name (must match blueprint definition)
            component: Component instance with process_item method
            ports: Port configuration {{port_name: handler_method}}
        """
        self._components[name] = component
        self._component_ports[name] = ports or {{"input": "process_item"}}
        self.logger.info(f"Registered component '{{name}}' with ports: {{list((ports or {{}}).keys())}}")
    
    def get_component(self, name: str) -> Optional[Any]:
        """Get component instance by name"""
        component = self._components.get(name)
        if not component:
            self.logger.warning(f"Component '{{name}}' not found in registry")
        return component
    
    def get_component_port_handler(self, component_name: str, port_name: str) -> Optional[str]:
        """Get handler method name for component port"""
        component_ports = self._component_ports.get(component_name, {{}})
        return component_ports.get(port_name, "process_item")
    
    def list_components(self) -> List[str]:
        """Get list of registered component names"""
        return list(self._components.keys())
    
    def is_registered(self, name: str) -> bool:
        """Check if component is registered"""
        return name in self._components


class CommunicationConfig:
    """
    Blueprint-based routing configuration
    
    Parses blueprint bindings to create runtime routing rules
    for inter-component communication.
    """
    
    def __init__(self, bindings: List[Dict[str, Any]] = None):
        self.bindings = bindings or []
        self.routing_table = self._build_routing_table()
        self.logger = get_communication_logger("CommunicationConfig")
        
    def _build_routing_table(self) -> Dict[str, List[Dict[str, Any]]]:
        """Build routing table from blueprint bindings"""
        routing_table = {{}}
        
        for binding in self.bindings:
            source = binding.from_component
            source_port = getattr(binding, 'from_port', 'output')
            targets = binding.to_components
            target_ports = getattr(binding, 'to_ports', ['input'])
            
            if not source or not targets:
                continue
                
            route_key = f"{{source}}.{{source_port}}"
            if route_key not in routing_table:
                routing_table[route_key] = []
                
            # Handle multiple targets
            for i, target in enumerate(targets):
                target_port = target_ports[i] if i < len(target_ports) else target_ports[0]
                routing_table[route_key].append({{
                    "target_component": target,
                    "target_port": target_port
                }})
        
        return routing_table
    
    def get_routes(self, source_component: str, source_port: str = "output") -> List[Dict[str, Any]]:
        """Get routing targets for source component and port"""
        route_key = f"{{source_component}}.{{source_port}}"
        return self.routing_table.get(route_key, [])


class ComponentCommunicator:
    """
    Inter-component message routing and delivery system
    
    Handles the actual sending of messages between components based on
    blueprint bindings and component registry.
    """
    
    def __init__(self, registry: ComponentRegistry, config: CommunicationConfig = None):
        self.registry = registry
        self.config = config or CommunicationConfig()
        self.logger = get_communication_logger("ComponentCommunicator")
        self._message_history: List[MessageEnvelope] = []
        
    async def send_to_component(self, 
                              source_component: str,
                              target_component: str, 
                              data: Dict[str, Any],
                              target_port: str = "input",
                              message_type: str = "data") -> Dict[str, Any]:
        """
        Send message to specific target component
        
        Args:
            source_component: Name of sending component
            target_component: Name of target component
            data: Message data to send
            target_port: Target component port (default: input)
            message_type: Type of message (data, query, command, response)
            
        Returns:
            Response from target component or error information
        """
        
        # Create message envelope
        message = MessageEnvelope(
            source_component=source_component,
            target_component=target_component,
            target_port=target_port,
            data=data,
            message_type=message_type
        )
        
        self.logger.info(f"Sending {{message_type}} from {{source_component}} to {{target_component}}.{{target_port}}")
        self.logger.debug(f"Message data: {{json.dumps(data, indent=2)}}")
        
        try:
            # Get target component
            target = self.registry.get_component(target_component)
            if not target:
                error_msg = f"Target component '{{target_component}}' not registered"
                self.logger.error(error_msg)
                return {{"status": "error", "message": error_msg, "correlation_id": message.correlation_id}}
            
            # Get handler method for target port
            handler_name = self.registry.get_component_port_handler(target_component, target_port)
            if not hasattr(target, handler_name):
                error_msg = f"Target component '{{target_component}}' has no method '{{handler_name}}'"
                self.logger.error(error_msg)
                return {{"status": "error", "message": error_msg, "correlation_id": message.correlation_id}}
            
            # Call target component handler
            handler = getattr(target, handler_name)
            
            # Track message in history
            self._message_history.append(message)
            
            # Execute handler with message data
            if asyncio.iscoroutinefunction(handler):
                result = await handler(data)
            else:
                result = handler(data)
            
            self.logger.info(f"Successfully delivered message {{message.correlation_id}} to {{target_component}}")
            
            # Wrap result with metadata
            return {{
                "status": "success",
                "result": result,
                "correlation_id": message.correlation_id,
                "target_component": target_component,
                "target_port": target_port
            }}
            
        except Exception as e:
            error_msg = f"Error sending to {{target_component}}: {{str(e)}}"
            self.logger.error(error_msg)
            return {{
                "status": "error", 
                "message": error_msg,
                "correlation_id": message.correlation_id,
                "exception_type": type(e).__name__
            }}
    
    async def route_message(self, 
                          source_component: str, 
                          data: Dict[str, Any],
                          source_port: str = "output") -> List[Dict[str, Any]]:
        """
        Route message to all targets based on blueprint bindings
        
        Args:
            source_component: Name of sending component
            data: Message data to route
            source_port: Source port name (default: output)
            
        Returns:
            List of responses from all target components
        """
        
        routes = self.config.get_routes(source_component, source_port)
        if not routes:
            self.logger.warning(f"No routes found for {{source_component}}.{{source_port}}")
            return []
        
        self.logger.info(f"Routing from {{source_component}}.{{source_port}} to {{len(routes)}} targets")
        
        # Send to all targets concurrently
        tasks = []
        for route in routes:
            task = self.send_to_component(
                source_component=source_component,
                target_component=route["target_component"],
                data=data,
                target_port=route["target_port"]
            )
            tasks.append(task)
        
        # Wait for all deliveries
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results and exceptions
        processed_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                route = routes[i]
                processed_results.append({{
                    "status": "error",
                    "message": f"Exception in route to {{route['target_component']}}: {{str(result)}}",
                    "target_component": route["target_component"],
                    "exception_type": type(result).__name__
                }})
            else:
                processed_results.append(result)
        
        return processed_results
    
    async def query_component(self, 
                            source_component: str,
                            target_component: str, 
                            query: Dict[str, Any],
                            target_port: str = "query") -> Dict[str, Any]:
        """
        Send query to component and wait for response
        
        Args:
            source_component: Name of querying component
            target_component: Name of target component
            query: Query data
            target_port: Target port for query (default: query)
            
        Returns:
            Response from target component
        """
        return await self.send_to_component(
            source_component=source_component,
            target_component=target_component,
            data=query,
            target_port=target_port,
            message_type="query"
        )
    
    def get_message_history(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get recent message history for debugging"""
        recent_messages = self._message_history[-limit:] if limit else self._message_history
        return [msg.to_dict() for msg in recent_messages]
    
    def clear_message_history(self) -> None:
        """Clear message history"""
        self._message_history.clear()
        self.logger.info("Message history cleared")


# Configuration for {system_name}
# Routing configuration is loaded from system_config.yaml at runtime
# This avoids hardcoding configuration in the Python module

def create_system_communicator(bindings: List[Dict[str, Any]] = None) -> tuple[ComponentRegistry, ComponentCommunicator]:
    """
    Factory function to create configured communication system
    
    Args:
        bindings: Optional list of binding configurations (loaded from system_config.yaml)
        
    Returns:
        Tuple of (registry, communicator) configured for this system
    """
    # Create communication config from provided bindings or empty list
    config = CommunicationConfig(bindings or [])
    
    # Create registry and communicator
    registry = ComponentRegistry()
    communicator = ComponentCommunicator(registry, config)
    
    logger = get_communication_logger("SystemSetup")
    logger.info(f"Created communication system for {system_name}")
    logger.info(f"Routing config: {{len(config.routing_table)}} routes")
    
    return registry, communicator


# Export public interface
__all__ = [
    "ComponentRegistry",
    "ComponentCommunicator", 
    "CommunicationConfig",
    "MessageEnvelope",
    "create_system_communicator"
]
'''
        
        return module_content
    
    def _build_routing_config(self, bindings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Build routing configuration from blueprint bindings"""
        return {
            "bindings": bindings,
            "routing_rules": len(bindings),
            "generated_at": datetime.now().isoformat()
        }
    
    def _build_component_config(self, components: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Build component configuration for registry"""
        component_config = {}
        for component in components:
            name = component.get("name", "")
            component_type = component.get("type", "")
            inputs = component.get("inputs", [])
            outputs = component.get("outputs", [])
            
            ports = {}
            for input_port in inputs:
                port_name = input_port.get("name", "input")
                ports[port_name] = "process_item"  # Default handler
            
            component_config[name] = {
                "type": component_type,
                "ports": ports,
                "inputs": [inp.get("name") for inp in inputs],
                "outputs": [out.get("name") for out in outputs]
            }
        
        return component_config
    
    def estimate_communication_overhead(self, bindings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Estimate performance impact of communication framework"""
        total_routes = len(bindings)
        
        # Estimate average message routing cost
        avg_routes_per_component = total_routes / max(len(set(b.get("from_component", "") for b in bindings)), 1)
        
        return {
            "total_routes": total_routes,
            "avg_routes_per_component": avg_routes_per_component,
            "estimated_latency_ms": avg_routes_per_component * 0.5,  # 0.5ms per route
            "memory_overhead_kb": total_routes * 0.1  # 0.1KB per route
        }


def generate_communication_framework(system_name: str,
                                   bindings: List[Dict[str, Any]] = None,
                                   components: List[Dict[str, Any]] = None,
                                   output_dir: str = None) -> str:
    """
    Convenience function to generate communication framework
    
    Args:
        system_name: Name of the system
        bindings: Blueprint binding definitions
        components: Component definitions  
        output_dir: Optional output directory path
        
    Returns:
        Generated communication module code
    """
    generator = ComponentCommunicationGenerator()
    return generator.generate_communication_module(system_name, bindings, components)