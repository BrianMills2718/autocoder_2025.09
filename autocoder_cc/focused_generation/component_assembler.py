#!/usr/bin/env python3
"""
ComponentAssembler - Programmatic injection of boilerplate around business logic

This module takes pure business logic methods generated by LLMs and assembles
them into complete components by programmatically injecting all necessary
boilerplate code.
"""

import ast
import re
from typing import Dict, Any, List, Set
from .business_logic_spec import BusinessLogicSpec


class ComponentAssembler:
    """
    Assembles complete components by injecting boilerplate around business logic.
    
    Takes method-only implementations from LLMs and programmatically adds all
    necessary imports, class structure, initialization, and infrastructure code.
    """
    
    def assemble_component(self, business_method: str, business_spec: BusinessLogicSpec) -> str:
        """
        Assemble complete component from business logic method.
        
        Args:
            business_method: Pure business logic method implementation
            business_spec: Business requirements specification
            
        Returns:
            Complete component with injected boilerplate
            
        Raises:
            ValueError: If business method is invalid
        """
        # Validate business method
        self._validate_business_method(business_method)
        
        # Extract imports from business method
        required_imports = self._extract_required_imports(business_method)
        
        # Clean business method (remove internal imports)
        clean_method = self._clean_business_method(business_method)
        
        # Generate component parts
        imports_section = self._generate_imports_section(required_imports)
        base_class_section = self._generate_base_class()
        component_class_section = self._generate_component_class(
            clean_method, business_spec
        )
        
        # Assemble complete component
        component_parts = [
            imports_section,
            "",  # Empty line
            base_class_section,
            "",  # Empty line
            component_class_section
        ]
        
        return "\n".join(component_parts)
    
    def _validate_business_method(self, business_method: str) -> None:
        """Validate that business method has correct structure"""
        if not business_method.strip():
            raise ValueError("Business method cannot be empty")
            
        # Check for async def process_item
        if "async def process_item" not in business_method:
            if "def process_item" in business_method:
                raise ValueError("Business method must be async")
            else:
                raise ValueError("Method must be named 'process_item'")
            
        # Check for proper type hints
        if "Dict[str, Any]" not in business_method:
            raise ValueError("Method must have proper type hints")
            
        # Validate syntax
        try:
            # Add minimal class wrapper for parsing
            wrapped_method = f"class TempClass:\n    {business_method.replace(chr(10), chr(10) + '    ')}"
            ast.parse(wrapped_method)
        except SyntaxError as e:
            raise ValueError(f"Business method has invalid Python syntax: {e}")
    
    def _extract_required_imports(self, business_method: str) -> Set[str]:
        """Extract all import statements from business method"""
        imports = set()
        
        # Find all import lines
        import_patterns = [
            r'^import\s+[\w\.,\s]+$',
            r'^from\s+[\w\.]+\s+import\s+[\w\.,\s\*]+$'
        ]
        
        lines = business_method.split('\n')
        for line in lines:
            line = line.strip()
            for pattern in import_patterns:
                if re.match(pattern, line):
                    imports.add(line)
                    
        return imports
    
    def _clean_business_method(self, business_method: str) -> str:
        """Remove import statements from business method"""
        lines = business_method.split('\n')
        cleaned_lines = []
        
        for line in lines:
            stripped = line.strip()
            # Skip import lines
            if (stripped.startswith('import ') or 
                stripped.startswith('from ') and ' import ' in stripped):
                continue
            cleaned_lines.append(line)
            
        return '\n'.join(cleaned_lines)
    
    def _generate_imports_section(self, required_imports: Set[str]) -> str:
        """Generate complete imports section"""
        # Standard imports always needed
        standard_imports = [
            "import logging",
            "from typing import Dict, Any",
            "from abc import ABC, abstractmethod"
        ]
        
        # Add extracted imports
        all_imports = standard_imports + sorted(list(required_imports))
        
        # Remove duplicates while preserving order
        seen = set()
        unique_imports = []
        for imp in all_imports:
            if imp not in seen:
                seen.add(imp)
                unique_imports.append(imp)
                
        return '\n'.join(unique_imports)
    
    def _generate_base_class(self) -> str:
        """Generate base component class"""
        return '''class ComposedComponent:
    """Base class for standalone components with logging and configuration."""
    
    def __init__(self, name: str, config: Dict[str, Any] = None):
        self.name = name
        self.config = config or {}
        self.logger = self.get_logger()
    
    def get_logger(self) -> logging.Logger:
        """Get configured logger for this component."""
        logger = logging.getLogger(f"Component.{self.name}")
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger'''
    
    def _generate_component_class(self, clean_method: str, business_spec: BusinessLogicSpec) -> str:
        """Generate component-specific class with business method"""
        class_name = self._generate_class_name(business_spec.component_name)
        
        # Generate component-specific initialization
        init_method = self._generate_component_init(business_spec)
        
        # Properly indent the business method
        indented_method = self._indent_method(clean_method)
        
        class_template = f'''class {class_name}(ComposedComponent):
    """
    {business_spec.business_purpose}
    
    Component Type: {business_spec.component_type}
    """
    
{init_method}
    
{indented_method}'''
        
        return class_template
    
    def _generate_class_name(self, component_name: str) -> str:
        """Generate proper class name from component name"""
        # Convert snake_case to PascalCase
        words = component_name.replace('-', '_').split('_')
        class_name = ''.join(word.capitalize() for word in words)
        
        # Ensure it ends with Component
        if not class_name.endswith('Component'):
            class_name += 'Component'
            
        return class_name
    
    def _generate_component_init(self, business_spec: BusinessLogicSpec) -> str:
        """Generate component-specific initialization based on component type and requirements"""
        init_lines = [
            "def __init__(self, name: str, config: Dict[str, Any] = None):",
            "    super().__init__(name, config)"
        ]
        
        # Add component-type-specific initialization
        if business_spec.component_type == "Store":
            init_lines.append("    # Database/storage-specific initialization")
            if "connection_pool_size" in business_spec.quality_requirements:
                pool_size = business_spec.quality_requirements["connection_pool_size"]
                init_lines.append(f"    self.connection_pool_size = self.config.get('connection_pool_size', {pool_size})")
        
        elif business_spec.component_type == "APIEndpoint":
            init_lines.append("    # API endpoint-specific initialization")
            if "rate_limit_rps" in business_spec.quality_requirements:
                rate_limit = business_spec.quality_requirements["rate_limit_rps"]
                init_lines.append(f"    self.rate_limit_rps = self.config.get('rate_limit_rps', {rate_limit})")
                
        elif business_spec.component_type == "Source":
            init_lines.append("    # Data source-specific initialization")
            if "interval_seconds" in business_spec.quality_requirements:
                interval = business_spec.quality_requirements["interval_seconds"]
                init_lines.append(f"    self.interval_seconds = self.config.get('interval_seconds', {interval})")
                
        # Add quality requirements initialization
        for key, value in business_spec.quality_requirements.items():
            if key not in ["connection_pool_size", "rate_limit_rps", "interval_seconds"]:
                init_lines.append(f"    self.{key} = self.config.get('{key}', {repr(value)})")
        
        # Properly indent all lines
        indented_lines = []
        for line in init_lines:
            indented_lines.append(f"    {line}")
        return '\n'.join(indented_lines)
    
    def _indent_method(self, method: str) -> str:
        """Properly indent method for class inclusion"""
        lines = method.split('\n')
        indented_lines = []
        
        for line in lines:
            if line.strip():  # Non-empty lines
                # Add exactly 4 spaces for class method indentation
                indented_lines.append(f"    {line}")
            else:  # Empty lines - preserve them
                indented_lines.append("")
                
        return '\n'.join(indented_lines)