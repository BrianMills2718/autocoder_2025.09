#!/usr/bin/env python3
"""
Integration test for the complete LLM generation to validation pipeline.

This test ensures that components generated by the LLM pass validation
after lifecycle method injection.
"""

import pytest
import asyncio
from unittest.mock import MagicMock

from autocoder_cc.blueprint_language.llm_component_generator import LLMComponentGenerator
from autocoder_cc.validation.integration_validator import IntegrationValidator


class TestGenerationPipeline:
    """Test the complete pipeline from LLM generation to validation."""
    
    @pytest.mark.asyncio
    async def test_generated_component_passes_validation_after_injection(self):
        """Test that LLM-generated components pass validation after lifecycle injection."""
        generator = LLMComponentGenerator()
        validator = IntegrationValidator()
        
        # Mock blueprint component
        blueprint_component = MagicMock()
        blueprint_component.name = "TestStore"
        blueprint_component.type = "Store"
        blueprint_component.bindings = []
        blueprint_component.functions = [{
            'name': 'store_item',
            'inputs': ['item_data'],
            'outputs': ['item_id'],
            'business_logic': 'Store an item and return its unique ID'
        }]
        
        # Generate a component
        result = await generator.generate_component_structured(
            component_type="Store",
            component_name=blueprint_component.name,
            component_description="Test store component for lifecycle injection",
            component_config={
                "storage_type": "memory",
                "max_items": 1000
            },
            class_name=f"Generated{blueprint_component.type}_{blueprint_component.name}",
            inputs=[],
            outputs=[],
            system_context="Test system for validating lifecycle injection"
        )
        
        # Extract the implementation
        if isinstance(result, dict):
            component_code = result.get('implementation', result.get('code', str(result)))
        else:
            component_code = str(result)
        
        # The code should now pass validation with lifecycle methods
        validation_result = validator.validate_component_integration(
            component_code,
            'Store'
        )
        
        # Assertions
        assert validation_result['valid'], f"Validation failed: {validation_result['errors']}"
        
        # Specifically check that lifecycle method errors are gone
        lifecycle_errors = [err for err in validation_result['errors'] if 'lifecycle method' in err.lower()]
        assert len(lifecycle_errors) == 0, f"Still have lifecycle errors: {lifecycle_errors}"
        
        # Check that health status error is gone
        health_errors = [err for err in validation_result['errors'] if 'health_status' in err.lower()]
        assert len(health_errors) == 0, f"Still have health status errors: {health_errors}"
    
    @pytest.mark.asyncio
    async def test_api_component_with_bindings_passes_validation(self):
        """Test that API components with bindings pass validation after injection."""
        generator = LLMComponentGenerator()
        validator = IntegrationValidator()
        
        # Mock blueprint component
        blueprint_component = MagicMock()
        blueprint_component.name = "TestAPI"
        blueprint_component.type = "API"
        blueprint_component.bindings = ["TestStore"]
        blueprint_component.functions = [{
            'name': 'handle_request',
            'inputs': ['request_data'],
            'outputs': ['response_data'],
            'business_logic': 'Handle HTTP request and interact with store'
        }]
        
        # Generate the component
        result = await generator.generate_component_structured(
            component_type="API",
            component_name=blueprint_component.name,
            component_description="API component with store binding",
            component_config={
                "port": 8080,
                "host": "0.0.0.0"
            },
            class_name=f"Generated{blueprint_component.type}_{blueprint_component.name}",
            inputs=[],
            outputs=[],
            system_context="Test system with API and Store components"
        )
        
        # Extract the implementation
        if isinstance(result, dict):
            component_code = result.get('implementation', result.get('code', str(result)))
        else:
            component_code = str(result)
        
        # Validate
        validation_result = validator.validate_component_integration(
            component_code,
            'API'
        )
        
        assert validation_result['valid'], f"API validation failed: {validation_result['errors']}"
        
        # Check no lifecycle errors
        lifecycle_errors = [err for err in validation_result['errors'] if any(
            method in err.lower() for method in ['setup', 'cleanup', 'health_status', 'lifecycle']
        )]
        assert len(lifecycle_errors) == 0, f"API has lifecycle errors: {lifecycle_errors}"
    
    @pytest.mark.asyncio
    async def test_validation_warnings_vs_errors(self):
        """Test that warnings don't fail validation but errors do."""
        generator = LLMComponentGenerator()
        validator = IntegrationValidator()
        
        # Generate a minimal component
        result = await generator.generate_component_structured(
            component_type="Store",
            component_name="MinimalStore",
            component_description="Minimal store for testing warnings",
            component_config={},
            class_name="GeneratedStore_MinimalStore",
            inputs=[],
            outputs=[],
            system_context="Minimal test system"
        )
        
        if isinstance(result, dict):
            component_code = result.get('implementation', result.get('code', str(result)))
        else:
            component_code = str(result)
        
        validation_result = validator.validate_component_integration(
            component_code,
            'Store'
        )
        
        # Should be valid even with warnings
        assert validation_result['valid'], "Component should pass validation despite warnings"
        
        # But may have warnings (that's ok)
        print(f"Validation warnings: {validation_result['warnings']}")
    
    @pytest.mark.asyncio
    async def test_complex_component_validation(self):
        """Test validation of complex components with multiple methods."""
        generator = LLMComponentGenerator()
        validator = IntegrationValidator()
        
        # Generate a complex component
        result = await generator.generate_component_structured(
            component_type="StreamProcessor",
            component_name="DataProcessor",
            component_description="Complex stream processing component",
            component_config={
                "batch_size": 100,
                "timeout_ms": 5000,
                "processing_mode": "parallel"
            },
            class_name="GeneratedStreamProcessor_DataProcessor",
            inputs=["raw_data", "metadata"],
            outputs=["processed_data", "metrics"],
            system_context="Data processing pipeline with streaming capabilities"
        )
        
        if isinstance(result, dict):
            component_code = result.get('implementation', result.get('code', str(result)))
        else:
            component_code = str(result)
        
        validation_result = validator.validate_component_integration(
            component_code,
            'StreamProcessor'
        )
        
        # Should pass all validations
        assert validation_result['valid'], f"Complex component failed: {validation_result['errors']}"
        
        # No missing method errors
        method_errors = [err for err in validation_result['errors'] if 'missing' in err.lower() or 'method' in err.lower()]
        assert len(method_errors) == 0, f"Complex component has method errors: {method_errors}"