"""
Unit tests for component validation pipeline to identify lifecycle issues

This test file targets the specific bugs identified by smoke tests:
- Generated components fail validation due to async lifecycle issues
- Components have setup/cleanup method signature problems
"""

import pytest
import tempfile
import asyncio
from pathlib import Path
import sys

# Add project root to path for imports
project_root = Path(__file__).parent.parent.parent.absolute()
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from autocoder_cc.blueprint_language.system_generator import SystemGenerator
from autocoder_cc.validation.integration_validator import IntegrationValidator


class TestComponentValidationPipeline:
    """Test the component validation that's failing in system generation"""
    
    def test_system_generator_creates_instance(self):
        """Test that SystemGenerator can be instantiated (basic import test)"""
        with tempfile.TemporaryDirectory() as temp_dir:
            generator = SystemGenerator(output_dir=temp_dir)
            assert generator is not None
            assert str(generator.output_dir) == temp_dir
    
    @pytest.mark.asyncio
    async def test_simple_blueprint_parsing(self):
        """Test that SystemGenerator can parse a basic blueprint without validation"""
        blueprint_yaml = """
        system:
          name: test_simple
          description: "Simple test system"
          components:
            - name: test_api
              type: APIEndpoint
              description: "Test API endpoint"
              config:
                host: localhost
                port: 8080
            - name: test_store
              type: Store
              description: "Test store"
              config:
                storage_type: memory
          bindings: []
        """
        
        with tempfile.TemporaryDirectory() as temp_dir:
            generator = SystemGenerator(output_dir=temp_dir, bypass_validation=True, skip_deployment=True)
            
            # Try to parse blueprint without full validation
            try:
                # This should work without validation gate
                result = await generator.generate_system_from_yaml(blueprint_yaml)
                assert result is not None, "System generation should return result"
            except Exception as e:
                # If it fails, we want to see the exact error
                pytest.fail(f"Blueprint parsing failed with: {type(e).__name__}: {e}")
    
    @pytest.mark.asyncio
    async def test_generated_component_has_correct_methods(self):
        """Test that generated components have the required lifecycle methods"""
        # Read one of the debug components generated by smoke test
        debug_store_path = Path("/tmp/debug_todo_store.py")
        debug_api_path = Path("/tmp/debug_todo_api.py")
        
        if debug_store_path.exists():
            content = debug_store_path.read_text()
            
            # Check for setup method
            assert "def setup(" in content, "Generated component should have setup method"
            
            # Check for cleanup method  
            assert "def cleanup(" in content, "Generated component should have cleanup method"
            
            # Check if methods are async (this is probably the bug)
            setup_is_async = "async def setup(" in content
            cleanup_is_async = "async def cleanup(" in content
            
            # Report findings
            print(f"Store component setup is async: {setup_is_async}")
            print(f"Store component cleanup is async: {cleanup_is_async}")
            
            # The bug is likely here - methods should be async but aren't
            if not setup_is_async:
                pytest.fail("Generated component setup method should be async but isn't")
            if not cleanup_is_async:
                pytest.fail("Generated component cleanup method should be async but isn't")
        else:
            pytest.skip("No debug component file found - run smoke tests first")
    
    def test_integration_validator_identifies_lifecycle_issues(self):
        """Test the validation that's failing generated components"""
        validator = IntegrationValidator()
        
        # Test with sync methods (this should fail validation)
        bad_component_code = '''
class BadComponent(ComposedComponent):
    def __init__(self, name, config=None):
        super().__init__(name, config)
    
    def setup(self):
        """Sync setup - this is wrong"""
        pass
    
    def cleanup(self):
        """Sync cleanup - this is wrong"""  
        pass
        
    async def process_item(self, item):
        return item
'''
        
        # Test with async methods (this should pass validation)
        good_component_code = '''
class GoodComponent(ComposedComponent):
    def __init__(self, name, config=None):
        super().__init__(name, config)
    
    async def setup(self):
        """Async setup - this is correct"""
        pass
    
    async def cleanup(self):
        """Async cleanup - this is correct"""  
        pass
        
    async def process_item(self, item):
        return item
'''
        
        # Test pipeline validation
        bad_valid, bad_errors = validator.validate_pipeline(bad_component_code)
        good_valid, good_errors = validator.validate_pipeline(good_component_code)
        
        print(f"Bad component validation: {bad_valid}, errors: {bad_errors}")
        print(f"Good component validation: {good_valid}, errors: {good_errors}")
        
        # If validator doesn't currently check async methods, that's the bug
        # We need to enhance the validator or fix the generator
    
    @pytest.mark.asyncio
    async def test_generated_component_lifecycle(self):
        """Test that we can actually run setup/cleanup on generated component"""
        debug_store_path = Path("/tmp/debug_todo_store.py")
        
        if not debug_store_path.exists():
            pytest.skip("No debug component file found - run smoke tests first")
        
        # Try to import and instantiate the generated component
        import importlib.util
        spec = importlib.util.spec_from_file_location("debug_store", debug_store_path)
        debug_module = importlib.util.module_from_spec(spec)
        
        try:
            spec.loader.exec_module(debug_module)
            
            # Get the component class
            component_class = None
            for attr_name in dir(debug_module):
                attr = getattr(debug_module, attr_name)
                if isinstance(attr, type) and attr_name.startswith("Generated"):
                    component_class = attr
                    break
            
            if component_class is None:
                pytest.fail("Could not find generated component class")
            
            # Try to instantiate it
            component = component_class("test", {"storage_type": "memory"})
            
            # Try to run setup - this is where the async issue occurs
            try:
                if asyncio.iscoroutinefunction(component.setup):
                    await component.setup()
                else:
                    # If it's not async, call it directly
                    component.setup()
                    
                # Try cleanup too
                if asyncio.iscoroutinefunction(component.cleanup):
                    await component.cleanup()
                else:
                    component.cleanup()
                    
                print("âœ… Component lifecycle methods work")
                
            except Exception as e:
                pytest.fail(f"Component lifecycle failed: {type(e).__name__}: {e}")
                
        except Exception as e:
            pytest.fail(f"Could not import generated component: {type(e).__name__}: {e}")


class TestSpecificBugFixes:
    """Test specific fixes for the identified async lifecycle issues"""
    
    def test_store_component_base_has_async_methods(self):
        """Verify that the base Store component has async setup/cleanup"""
        from autocoder_cc.components.store import Store
        
        assert asyncio.iscoroutinefunction(Store.setup), "Store.setup should be async"
        assert asyncio.iscoroutinefunction(Store.cleanup), "Store.cleanup should be async"
    
    def test_composed_base_has_async_methods(self):
        """Verify that ComposedComponent base has async setup/cleanup"""
        from autocoder_cc.components.composed_base import ComposedComponent
        
        # Check if ComposedComponent has the methods at all
        assert hasattr(ComposedComponent, 'setup'), "ComposedComponent should have setup method"
        assert hasattr(ComposedComponent, 'cleanup'), "ComposedComponent should have cleanup method"
        
        # Check if they're async (this might be the missing piece)
        setup_is_async = asyncio.iscoroutinefunction(ComposedComponent.setup)
        cleanup_is_async = asyncio.iscoroutinefunction(ComposedComponent.cleanup)
        
        print(f"ComposedComponent.setup is async: {setup_is_async}")
        print(f"ComposedComponent.cleanup is async: {cleanup_is_async}")
        
        # If these aren't async, that's likely the bug
        if not setup_is_async:
            pytest.fail("ComposedComponent.setup should be async")
        if not cleanup_is_async:
            pytest.fail("ComposedComponent.cleanup should be async")